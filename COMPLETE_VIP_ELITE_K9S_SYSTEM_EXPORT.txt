# VIP ELITE K9S COMPLETE SYSTEM EXPORT
# Generated: May 26, 2025
# Complete codebase for the VIP Elite K9s Management System

## PROJECT STRUCTURE
```
├── client/
│   ├── src/
│   │   ├── components/ui/ (Shadcn components)
│   │   ├── hooks/
│   │   ├── lib/
│   │   └── pages/
│   └── index.html
├── server/
├── shared/
└── configuration files
```

## PACKAGE.JSON
```json
{
  "name": "rest-express",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "npm run build:client && npm run build:server",
    "build:client": "vite build",
    "build:server": "esbuild server/index.ts --bundle --platform=node --target=node18 --outfile=dist/index.js --external:@neondatabase/serverless",
    "start": "node dist/index.js",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.1",
    "@neondatabase/serverless": "^0.10.6",
    "@radix-ui/react-accordion": "^1.2.1",
    "@radix-ui/react-alert-dialog": "^1.1.2",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-collapsible": "^1.1.1",
    "@radix-ui/react-context-menu": "^2.2.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-hover-card": "^1.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.2",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.1",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@tanstack/react-query": "^5.61.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.4",
    "date-fns": "^4.1.0",
    "drizzle-orm": "^0.36.4",
    "drizzle-zod": "^0.5.1",
    "embla-carousel-react": "^8.3.1",
    "express": "^4.21.1",
    "framer-motion": "^11.12.0",
    "input-otp": "^1.4.1",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.4.4",
    "react": "^18.3.1",
    "react-day-picker": "^9.4.2",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.54.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.13.3",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^1.1.1",
    "wouter": "^3.3.5",
    "zod": "^3.23.8",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@types/express": "^5.0.0",
    "@types/node": "^22.9.1",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.3",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.29.1",
    "esbuild": "^0.24.0",
    "postcss": "^8.5.0",
    "tailwindcss": "^3.4.15",
    "tsx": "^4.19.2",
    "typescript": "^5.6.3",
    "vite": "^5.4.10"
  }
}
```

## SHARED/SCHEMA.TS
```typescript
import {
  pgTable,
  serial,
  text,
  integer,
  timestamp,
  varchar,
  boolean,
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Users table (for admin authentication)
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: varchar("username", { length: 50 }).notNull().unique(),
  password: varchar("password", { length: 255 }).notNull(),
  role: varchar("role", { length: 20 }).notNull().default("admin"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Staff table
export const staff = pgTable("staff", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 100 }).notNull(),
  role: varchar("role", { length: 50 }).notNull(),
  pin: varchar("pin", { length: 4 }).notNull().unique(),
  isActive: boolean("is_active").notNull().default(true),
  photo: text("photo"),
  email: varchar("email", { length: 100 }),
  phone: varchar("phone", { length: 20 }),
  hourlyRate: integer("hourly_rate"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Clients table
export const clients = pgTable("clients", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 100 }).notNull(),
  email: varchar("email", { length: 100 }).notNull().unique(),
  phone: varchar("phone", { length: 20 }),
  address: text("address"),
  emergencyContact: text("emergency_contact"),
  emergencyPhone: varchar("emergency_phone", { length: 20 }),
  vetName: varchar("vet_name", { length: 100 }),
  vetPhone: varchar("vet_phone", { length: 20 }),
  vetAddress: text("vet_address"),
  password: varchar("password", { length: 255 }),
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

// Dogs table
export const dogs = pgTable("dogs", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 50 }).notNull(),
  breed: varchar("breed", { length: 50 }),
  age: integer("age"),
  weight: varchar("weight", { length: 10 }),
  clientId: integer("client_id").notNull(),
  photo: text("photo"),
  feedingInstructions: text("feeding_instructions"),
  feedingTimes: text("feeding_times"),
  medication: text("medication"),
  medicationSchedule: text("medication_schedule"),
  specialNotes: text("special_notes"),
  behaviorNotes: text("behavior_notes"),
  emergencyContact: text("emergency_contact"),
  vetInfo: text("vet_info"),
  itemsBrought: text("items_brought"),
  allergies: text("allergies"),
  exerciseRequirements: text("exercise_requirements"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Kennels table
export const kennels = pgTable("kennels", {
  id: serial("id").primaryKey(),
  number: integer("number").notNull().unique(),
  status: varchar("status", { length: 20 }).notNull().default("available"), // available, occupied, cleaning
  dogId: integer("dog_id"),
  dogIds: integer("dog_ids").array().default([]),
  checkInDate: timestamp("check_in_date"),
  checkOutDate: timestamp("check_out_date"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Jobs table
export const jobs = pgTable("jobs", {
  id: serial("id").primaryKey(),
  type: text("type").notNull(), // walk, training, cleaning, feeding, grooming
  description: text("description").notNull(),
  assignedStaffId: integer("assigned_staff_id"),
  dogId: integer("dog_id"),
  kennelId: integer("kennel_id"),
  scheduledDate: timestamp("scheduled_date").notNull(),
  scheduledTime: text("scheduled_time"),
  status: text("status").notNull().default("pending"), // pending, in_progress, completed
  notes: text("notes"),
  completedAt: timestamp("completed_at"),
});

// Bookings table
export const bookings = pgTable("bookings", {
  id: serial("id").primaryKey(),
  clientId: integer("client_id").notNull(),
  dogId: integer("dog_id").notNull(),
  serviceType: text("service_type").notNull(), // boarding, training, walking, grooming
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date"),
  duration: integer("duration"), // in minutes for training/walking
  status: text("status").notNull().default("pending"), // pending, confirmed, in_progress, completed, cancelled
  notes: text("notes"),
  totalAmount: integer("total_amount"), // in pence
});

// Staff time tracking table
export const timeEntries = pgTable("time_entries", {
  id: serial("id").primaryKey(),
  staffId: integer("staff_id").notNull(),
  clockInTime: timestamp("clock_in_time").notNull(),
  clockOutTime: timestamp("clock_out_time"),
  breakStartTime: timestamp("break_start_time"),
  breakEndTime: timestamp("break_end_time"),
  totalHours: integer("total_hours"), // in minutes
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Daily reports table
export const dailyReports = pgTable("daily_reports", {
  id: serial("id").primaryKey(),
  dogId: integer("dog_id").notNull(),
  date: timestamp("date").notNull(),
  feeding: text("feeding"),
  exercise: text("exercise"),
  behavior: text("behavior"),
  medication: text("medication"),
  notes: text("notes"),
  staffId: integer("staff_id"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Invoices table
export const invoices = pgTable("invoices", {
  id: serial("id").primaryKey(),
  clientId: integer("client_id").notNull(),
  invoiceNumber: varchar("invoice_number", { length: 50 }).notNull().unique(),
  totalAmount: integer("total_amount").notNull(), // in pence
  paidAmount: integer("paid_amount").default(0),
  status: varchar("status", { length: 20 }).notNull().default("pending"), // pending, paid, overdue
  dueDate: timestamp("due_date"),
  paidDate: timestamp("paid_date"),
  items: text("items"), // JSON string of invoice items
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Kennel logs table
export const kennelLogs = pgTable("kennel_logs", {
  id: serial("id").primaryKey(),
  kennelId: integer("kennel_id").notNull(),
  dogId: integer("dog_id"),
  staffId: integer("staff_id").notNull(),
  action: varchar("action", { length: 50 }).notNull(), // check_in, check_out, cleaning, feeding, walk
  timestamp: timestamp("timestamp").notNull().defaultNow(),
  notes: text("notes"),
});

// Insert schemas for validation
export const insertUserSchema = createInsertSchema(users).omit({ id: true });
export const insertStaffSchema = createInsertSchema(staff).omit({ id: true });
export const insertClientSchema = createInsertSchema(clients).omit({ id: true });
export const insertDogSchema = createInsertSchema(dogs).omit({ id: true });
export const insertKennelSchema = createInsertSchema(kennels).omit({ id: true });
export const insertJobSchema = createInsertSchema(jobs).omit({ id: true });
export const insertBookingSchema = createInsertSchema(bookings).omit({ id: true });
export const insertTimeEntrySchema = createInsertSchema(timeEntries).omit({ id: true });
export const insertDailyReportSchema = createInsertSchema(dailyReports).omit({ id: true });
export const insertInvoiceSchema = createInsertSchema(invoices).omit({ id: true });
export const insertKennelLogSchema = createInsertSchema(kennelLogs).omit({ id: true });

// Types
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
export type Staff = typeof staff.$inferSelect;
export type InsertStaff = z.infer<typeof insertStaffSchema>;
export type Client = typeof clients.$inferSelect;
export type InsertClient = z.infer<typeof insertClientSchema>;
export type Dog = typeof dogs.$inferSelect;
export type InsertDog = z.infer<typeof insertDogSchema>;
export type Kennel = typeof kennels.$inferSelect;
export type InsertKennel = z.infer<typeof insertKennelSchema>;
export type Job = typeof jobs.$inferSelect;
export type InsertJob = z.infer<typeof insertJobSchema>;
export type Booking = typeof bookings.$inferSelect;
export type InsertBooking = z.infer<typeof insertBookingSchema>;
export type TimeEntry = typeof timeEntries.$inferSelect;
export type InsertTimeEntry = z.infer<typeof insertTimeEntrySchema>;
export type DailyReport = typeof dailyReports.$inferSelect;
export type InsertDailyReport = z.infer<typeof insertDailyReportSchema>;
export type Invoice = typeof invoices.$inferSelect;
export type InsertInvoice = z.infer<typeof insertInvoiceSchema>;
export type KennelLog = typeof kennelLogs.$inferSelect;
export type InsertKennelLog = z.infer<typeof insertKennelLogSchema>;
```

## SERVER/DB.TS
```typescript
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";
import * as schema from "@shared/schema";

neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle({ client: pool, schema });
```

## SERVER/STORAGE.TS
```typescript
import {
  users,
  staff,
  clients,
  dogs,
  kennels,
  jobs,
  bookings,
  timeEntries,
  dailyReports,
  invoices,
  kennelLogs,
  type User,
  type InsertUser,
  type Staff,
  type InsertStaff,
  type Client,
  type InsertClient,
  type Dog,
  type InsertDog,
  type Kennel,
  type InsertKennel,
  type Job,
  type InsertJob,
  type Booking,
  type InsertBooking,
  type TimeEntry,
  type InsertTimeEntry,
  type DailyReport,
  type InsertDailyReport,
  type Invoice,
  type InsertInvoice,
  type KennelLog,
  type InsertKennelLog,
} from "@shared/schema";
import { db } from "./db";
import { eq, and } from "drizzle-orm";

export interface IStorage {
  // Users
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;

  // Staff
  getAllStaff(): Promise<Staff[]>;
  getStaff(id: number): Promise<Staff | undefined>;
  getStaffByPin(pin: string): Promise<Staff | undefined>;
  createStaff(staff: InsertStaff): Promise<Staff>;
  updateStaff(id: number, updates: Partial<Staff>): Promise<Staff | undefined>;

  // Clients
  getAllClients(): Promise<Client[]>;
  getClient(id: number): Promise<Client | undefined>;
  getClientByEmail(email: string): Promise<Client | undefined>;
  createClient(client: InsertClient): Promise<Client>;
  updateClient(id: number, updates: Partial<Client>): Promise<Client | undefined>;
  deleteClient(id: number): Promise<boolean>;

  // Dogs
  getAllDogs(): Promise<Dog[]>;
  getDog(id: number): Promise<Dog | undefined>;
  getDogsByClient(clientId: number): Promise<Dog[]>;
  createDog(dog: InsertDog): Promise<Dog>;
  updateDog(id: number, updates: Partial<Dog>): Promise<Dog | undefined>;
  deleteDog(id: number): Promise<boolean>;

  // Kennels
  getAllKennels(): Promise<Kennel[]>;
  getKennel(id: number): Promise<Kennel | undefined>;
  getKennelByNumber(number: number): Promise<Kennel | undefined>;
  createKennel(kennel: InsertKennel): Promise<Kennel>;
  updateKennel(id: number, updates: Partial<Kennel>): Promise<Kennel | undefined>;

  // Jobs
  getAllJobs(): Promise<Job[]>;
  getJob(id: number): Promise<Job | undefined>;
  getJobsByStaff(staffId: number): Promise<Job[]>;
  getJobsByDate(date: string): Promise<Job[]>;
  createJob(job: InsertJob): Promise<Job>;
  updateJob(id: number, updates: Partial<Job>): Promise<Job | undefined>;

  // Bookings
  getAllBookings(): Promise<Booking[]>;
  getBooking(id: number): Promise<Booking | undefined>;
  getBookingsByClient(clientId: number): Promise<Booking[]>;
  createBooking(booking: InsertBooking): Promise<Booking>;
  updateBooking(id: number, updates: Partial<Booking>): Promise<Booking | undefined>;

  // Daily Reports
  getDailyReport(dogId: number, date: string): Promise<DailyReport | undefined>;
  createDailyReport(report: InsertDailyReport): Promise<DailyReport>;
  updateDailyReport(id: number, updates: Partial<DailyReport>): Promise<DailyReport | undefined>;

  // Invoices
  getAllInvoices(): Promise<Invoice[]>;
  getInvoice(id: number): Promise<Invoice | undefined>;
  getInvoicesByClient(clientId: number): Promise<Invoice[]>;
  createInvoice(invoice: InsertInvoice): Promise<Invoice>;
  updateInvoice(id: number, updates: Partial<Invoice>): Promise<Invoice | undefined>;

  // Time Entries
  getAllTimeEntries(): Promise<TimeEntry[]>;
  getTimeEntry(id: number): Promise<TimeEntry | undefined>;
  getTimeEntriesByStaff(staffId: number): Promise<TimeEntry[]>;
  getTimeEntriesByDate(date: string): Promise<TimeEntry[]>;
  createTimeEntry(timeEntry: InsertTimeEntry): Promise<TimeEntry>;
  updateTimeEntry(id: number, updates: Partial<TimeEntry>): Promise<TimeEntry | undefined>;

  // Kennel Logs
  getAllKennelLogs(): Promise<KennelLog[]>;
  getKennelLog(id: number): Promise<KennelLog | undefined>;
  getKennelLogsByKennel(kennelId: number): Promise<KennelLog[]>;
  getKennelLogsByDog(dogId: number): Promise<KennelLog[]>;
  getKennelLogsByStaff(staffId: number): Promise<KennelLog[]>;
  getKennelLogsByDate(date: string): Promise<KennelLog[]>;
  createKennelLog(kennelLog: InsertKennelLog): Promise<KennelLog>;
  updateKennelLog(id: number, updates: Partial<KennelLog>): Promise<KennelLog | undefined>;
}

class DatabaseStorage implements IStorage {
  // Users
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db.insert(users).values(insertUser).returning();
    return user;
  }

  // Staff
  async getAllStaff(): Promise<Staff[]> {
    return await db.select().from(staff);
  }

  async getStaff(id: number): Promise<Staff | undefined> {
    const [staffMember] = await db.select().from(staff).where(eq(staff.id, id));
    return staffMember;
  }

  async getStaffByPin(pin: string): Promise<Staff | undefined> {
    const [staffMember] = await db.select().from(staff).where(eq(staff.pin, pin));
    return staffMember;
  }

  async createStaff(insertStaff: InsertStaff): Promise<Staff> {
    const [staffMember] = await db.insert(staff).values(insertStaff).returning();
    return staffMember;
  }

  async updateStaff(id: number, updates: Partial<Staff>): Promise<Staff | undefined> {
    const [updated] = await db.update(staff).set(updates).where(eq(staff.id, id)).returning();
    return updated;
  }

  // Clients
  async getAllClients(): Promise<Client[]> {
    return await db.select().from(clients);
  }

  async getClient(id: number): Promise<Client | undefined> {
    const [client] = await db.select().from(clients).where(eq(clients.id, id));
    return client;
  }

  async getClientByEmail(email: string): Promise<Client | undefined> {
    const [client] = await db.select().from(clients).where(eq(clients.email, email));
    return client;
  }

  async createClient(insertClient: InsertClient): Promise<Client> {
    const [client] = await db.insert(clients).values(insertClient).returning();
    return client;
  }

  async updateClient(id: number, updates: Partial<Client>): Promise<Client | undefined> {
    console.log("Database: Updating client", id, "with:", updates);
    
    // Handle date fields properly
    const processedUpdates = { ...updates };
    if (processedUpdates.createdAt && typeof processedUpdates.createdAt === 'string') {
      processedUpdates.createdAt = new Date(processedUpdates.createdAt);
    }
    
    const [updated] = await db.update(clients).set(processedUpdates).where(eq(clients.id, id)).returning();
    console.log("Database: Client updated:", updated);
    return updated;
  }

  async deleteClient(id: number): Promise<boolean> {
    const result = await db.delete(clients).where(eq(clients.id, id));
    return result.rowCount > 0;
  }

  // Dogs
  async getAllDogs(): Promise<Dog[]> {
    return await db.select().from(dogs);
  }

  async getDog(id: number): Promise<Dog | undefined> {
    const [dog] = await db.select().from(dogs).where(eq(dogs.id, id));
    return dog;
  }

  async getDogsByClient(clientId: number): Promise<Dog[]> {
    return await db.select().from(dogs).where(eq(dogs.clientId, clientId));
  }

  async createDog(insertDog: InsertDog): Promise<Dog> {
    const [dog] = await db.insert(dogs).values(insertDog).returning();
    return dog;
  }

  async updateDog(id: number, updates: Partial<Dog>): Promise<Dog | undefined> {
    const processedUpdates = { ...updates, updatedAt: new Date() };
    const [updated] = await db.update(dogs).set(processedUpdates).where(eq(dogs.id, id)).returning();
    return updated;
  }

  async deleteDog(id: number): Promise<boolean> {
    const result = await db.delete(dogs).where(eq(dogs.id, id));
    return result.rowCount > 0;
  }

  // Kennels
  async getAllKennels(): Promise<Kennel[]> {
    return await db.select().from(kennels);
  }

  async getKennel(id: number): Promise<Kennel | undefined> {
    const [kennel] = await db.select().from(kennels).where(eq(kennels.id, id));
    return kennel;
  }

  async getKennelByNumber(number: number): Promise<Kennel | undefined> {
    const [kennel] = await db.select().from(kennels).where(eq(kennels.number, number));
    return kennel;
  }

  async createKennel(insertKennel: InsertKennel): Promise<Kennel> {
    const [kennel] = await db.insert(kennels).values(insertKennel).returning();
    return kennel;
  }

  async updateKennel(id: number, updates: Partial<Kennel>): Promise<Kennel | undefined> {
    console.log("Database: Updating kennel", id, "with:", updates);
    const processedUpdates = { ...updates, updatedAt: new Date() };
    const [updated] = await db.update(kennels).set(processedUpdates).where(eq(kennels.id, id)).returning();
    console.log("Database: Kennel updated:", updated);
    return updated;
  }

  // Jobs
  async getAllJobs(): Promise<Job[]> {
    return await db.select().from(jobs);
  }

  async getJob(id: number): Promise<Job | undefined> {
    const [job] = await db.select().from(jobs).where(eq(jobs.id, id));
    return job;
  }

  async getJobsByStaff(staffId: number): Promise<Job[]> {
    return await db.select().from(jobs).where(eq(jobs.assignedStaffId, staffId));
  }

  async getJobsByDate(date: string): Promise<Job[]> {
    const startDate = new Date(date);
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + 1);
    
    return await db.select().from(jobs).where(
      and(
        eq(jobs.scheduledDate, startDate)
      )
    );
  }

  async createJob(insertJob: InsertJob): Promise<Job> {
    const [job] = await db.insert(jobs).values(insertJob).returning();
    return job;
  }

  async updateJob(id: number, updates: Partial<Job>): Promise<Job | undefined> {
    const [updated] = await db.update(jobs).set(updates).where(eq(jobs.id, id)).returning();
    return updated;
  }

  // Bookings
  async getAllBookings(): Promise<Booking[]> {
    return await db.select().from(bookings);
  }

  async getBooking(id: number): Promise<Booking | undefined> {
    const [booking] = await db.select().from(bookings).where(eq(bookings.id, id));
    return booking;
  }

  async getBookingsByClient(clientId: number): Promise<Booking[]> {
    return await db.select().from(bookings).where(eq(bookings.clientId, clientId));
  }

  async createBooking(insertBooking: InsertBooking): Promise<Booking> {
    const [booking] = await db.insert(bookings).values(insertBooking).returning();
    return booking;
  }

  async updateBooking(id: number, updates: Partial<Booking>): Promise<Booking | undefined> {
    const [updated] = await db.update(bookings).set(updates).where(eq(bookings.id, id)).returning();
    return updated;
  }

  // Daily Reports
  async getDailyReport(dogId: number, date: string): Promise<DailyReport | undefined> {
    const reportDate = new Date(date);
    const [report] = await db.select().from(dailyReports).where(
      and(eq(dailyReports.dogId, dogId), eq(dailyReports.date, reportDate))
    );
    return report;
  }

  async createDailyReport(insertReport: InsertDailyReport): Promise<DailyReport> {
    const [report] = await db.insert(dailyReports).values(insertReport).returning();
    return report;
  }

  async updateDailyReport(id: number, updates: Partial<DailyReport>): Promise<DailyReport | undefined> {
    const [updated] = await db.update(dailyReports).set(updates).where(eq(dailyReports.id, id)).returning();
    return updated;
  }

  // Invoices
  async getAllInvoices(): Promise<Invoice[]> {
    return await db.select().from(invoices);
  }

  async getInvoice(id: number): Promise<Invoice | undefined> {
    const [invoice] = await db.select().from(invoices).where(eq(invoices.id, id));
    return invoice;
  }

  async getInvoicesByClient(clientId: number): Promise<Invoice[]> {
    return await db.select().from(invoices).where(eq(invoices.clientId, clientId));
  }

  async createInvoice(insertInvoice: InsertInvoice): Promise<Invoice> {
    const [invoice] = await db.insert(invoices).values(insertInvoice).returning();
    return invoice;
  }

  async updateInvoice(id: number, updates: Partial<Invoice>): Promise<Invoice | undefined> {
    const [updated] = await db.update(invoices).set(updates).where(eq(invoices.id, id)).returning();
    return updated;
  }

  // Time Entries
  async getAllTimeEntries(): Promise<TimeEntry[]> {
    return await db.select().from(timeEntries);
  }

  async getTimeEntry(id: number): Promise<TimeEntry | undefined> {
    const [entry] = await db.select().from(timeEntries).where(eq(timeEntries.id, id));
    return entry;
  }

  async getTimeEntriesByStaff(staffId: number): Promise<TimeEntry[]> {
    return await db.select().from(timeEntries).where(eq(timeEntries.staffId, staffId));
  }

  async getTimeEntriesByDate(date: string): Promise<TimeEntry[]> {
    const targetDate = new Date(date);
    return await db.select().from(timeEntries).where(eq(timeEntries.clockInTime, targetDate));
  }

  async createTimeEntry(insertTimeEntry: InsertTimeEntry): Promise<TimeEntry> {
    const [entry] = await db.insert(timeEntries).values(insertTimeEntry).returning();
    return entry;
  }

  async updateTimeEntry(id: number, updates: Partial<TimeEntry>): Promise<TimeEntry | undefined> {
    const [updated] = await db.update(timeEntries).set(updates).where(eq(timeEntries.id, id)).returning();
    return updated;
  }

  // Kennel Logs
  async getAllKennelLogs(): Promise<KennelLog[]> {
    return await db.select().from(kennelLogs);
  }

  async getKennelLog(id: number): Promise<KennelLog | undefined> {
    const [log] = await db.select().from(kennelLogs).where(eq(kennelLogs.id, id));
    return log;
  }

  async getKennelLogsByKennel(kennelId: number): Promise<KennelLog[]> {
    return await db.select().from(kennelLogs).where(eq(kennelLogs.kennelId, kennelId));
  }

  async getKennelLogsByDog(dogId: number): Promise<KennelLog[]> {
    return await db.select().from(kennelLogs).where(eq(kennelLogs.dogId, dogId));
  }

  async getKennelLogsByStaff(staffId: number): Promise<KennelLog[]> {
    return await db.select().from(kennelLogs).where(eq(kennelLogs.staffId, staffId));
  }

  async getKennelLogsByDate(date: string): Promise<KennelLog[]> {
    const targetDate = new Date(date);
    return await db.select().from(kennelLogs).where(eq(kennelLogs.timestamp, targetDate));
  }

  async createKennelLog(insertKennelLog: InsertKennelLog): Promise<KennelLog> {
    const [log] = await db.insert(kennelLogs).values(insertKennelLog).returning();
    return log;
  }

  async updateKennelLog(id: number, updates: Partial<KennelLog>): Promise<KennelLog | undefined> {
    const [updated] = await db.update(kennelLogs).set(updates).where(eq(kennelLogs.id, id)).returning();
    return updated;
  }
}

export const storage = new DatabaseStorage();
```

## SERVER/ROUTES.TS
```typescript
import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import {
  insertUserSchema,
  insertStaffSchema,
  insertClientSchema,
  insertDogSchema,
  insertKennelSchema,
  insertJobSchema,
  insertBookingSchema,
  insertTimeEntrySchema,
  insertDailyReportSchema,
  insertInvoiceSchema,
  insertKennelLogSchema,
} from "@shared/schema";

export async function registerRoutes(app: Express): Promise<Server> {
  // Admin authentication routes
  app.post("/api/auth/admin-login", async (req, res) => {
    try {
      const { username, password } = req.body;
      const user = await storage.getUserByUsername(username);
      
      if (!user || user.password !== password) {
        return res.status(401).json({ message: "Invalid username or password" });
      }
      
      res.json({ 
        user: { id: user.id, username: user.username, role: user.role },
        message: "Login successful"
      });
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Staff authentication routes
  app.post("/api/auth/staff-login", async (req, res) => {
    try {
      const { pin } = req.body;
      const staffMember = await storage.getStaffByPin(pin);
      
      if (!staffMember || !staffMember.isActive) {
        return res.status(401).json({ message: "Invalid PIN or inactive staff member" });
      }
      
      res.json({ 
        staff: {
          id: staffMember.id,
          name: staffMember.name,
          role: staffMember.role,
          photo: staffMember.photo
        },
        message: "Login successful"
      });
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Client authentication routes
  app.post("/api/auth/client-login", async (req, res) => {
    try {
      const { email, password } = req.body;
      const client = await storage.getClientByEmail(email);
      
      if (!client || client.password !== password) {
        return res.status(401).json({ message: "Invalid email or password" });
      }
      
      res.json({ 
        client: {
          id: client.id,
          name: client.name,
          email: client.email,
          phone: client.phone,
          address: client.address
        },
        message: "Login successful"
      });
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Client routes
  app.get("/api/clients", async (req, res) => {
    try {
      const clients = await storage.getAllClients();
      res.json(clients);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/clients", async (req, res) => {
    try {
      const validatedData = insertClientSchema.parse(req.body);
      const client = await storage.createClient(validatedData);
      res.json(client);
    } catch (error) {
      res.status(500).json({ message: "Failed to create client" });
    }
  });

  app.patch("/api/clients/:id", async (req, res) => {
    try {
      const clientId = parseInt(req.params.id);
      const updates = req.body;
      
      const updated = await storage.updateClient(clientId, updates);
      
      if (!updated) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      res.json(updated);
    } catch (error) {
      console.error("Error updating client:", error);
      res.status(500).json({ message: "Failed to update client" });
    }
  });

  app.delete("/api/clients/:id", async (req, res) => {
    try {
      const clientId = parseInt(req.params.id);
      const deleted = await storage.deleteClient(clientId);
      
      if (!deleted) {
        return res.status(404).json({ message: "Client not found" });
      }
      
      res.json({ message: "Client deleted successfully" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete client" });
    }
  });

  // Dog routes
  app.get("/api/dogs", async (req, res) => {
    try {
      const dogs = await storage.getAllDogs();
      res.json(dogs);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/dogs", async (req, res) => {
    try {
      const validatedData = insertDogSchema.parse(req.body);
      const dog = await storage.createDog(validatedData);
      res.json(dog);
    } catch (error) {
      res.status(500).json({ message: "Failed to create dog" });
    }
  });

  app.patch("/api/dogs/:id", async (req, res) => {
    try {
      const dogId = parseInt(req.params.id);
      const updates = req.body;
      
      const updated = await storage.updateDog(dogId, updates);
      
      if (!updated) {
        return res.status(404).json({ message: "Dog not found" });
      }
      
      res.json(updated);
    } catch (error) {
      console.error("Error updating dog:", error);
      res.status(500).json({ message: "Failed to update dog" });
    }
  });

  app.delete("/api/dogs/:id", async (req, res) => {
    try {
      const dogId = parseInt(req.params.id);
      const deleted = await storage.deleteDog(dogId);
      
      if (!deleted) {
        return res.status(404).json({ message: "Dog not found" });
      }
      
      res.json({ message: "Dog deleted successfully" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete dog" });
    }
  });

  // Staff routes
  app.get("/api/staff", async (req, res) => {
    try {
      const staff = await storage.getAllStaff();
      res.json(staff);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/staff", async (req, res) => {
    try {
      const validatedData = insertStaffSchema.parse(req.body);
      const staffMember = await storage.createStaff(validatedData);
      res.json(staffMember);
    } catch (error) {
      res.status(500).json({ message: "Failed to create staff member" });
    }
  });

  app.patch("/api/staff/:id", async (req, res) => {
    try {
      const staffId = parseInt(req.params.id);
      const updates = req.body;
      
      const updated = await storage.updateStaff(staffId, updates);
      
      if (!updated) {
        return res.status(404).json({ message: "Staff member not found" });
      }
      
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update staff member" });
    }
  });

  // Kennel routes
  app.get("/api/kennels", async (req, res) => {
    try {
      const kennels = await storage.getAllKennels();
      res.json(kennels);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/kennels/assign", async (req, res) => {
    console.log("🚀 ENHANCED KENNEL ASSIGNMENT STARTED");
    try {
      const { kennelIds, dogIds, checkInDate, checkOutDate } = req.body;
      
      console.log("📝 Request data:", { kennelIds, dogIds, checkInDate, checkOutDate });

      if (!Array.isArray(kennelIds) || !Array.isArray(dogIds)) {
        return res.status(400).json({ message: "Invalid kennel or dog selection" });
      }

      if (kennelIds.length !== 1) {
        return res.status(400).json({ message: "Can only assign to one kennel at a time" });
      }

      if (dogIds.length > 2) {
        return res.status(400).json({ message: "Maximum 2 dogs per kennel allowed" });
      }

      const kennelId = kennelIds[0];
      const kennel = await storage.getKennel(kennelId);
      
      if (!kennel) {
        return res.status(404).json({ message: "Kennel not found" });
      }

      // Check if kennel already has dogs
      const currentDogIds = kennel.dogIds || [];
      const totalDogsAfterAssignment = currentDogIds.length + dogIds.length;
      
      if (totalDogsAfterAssignment > 2) {
        return res.status(400).json({ message: "Cannot exceed 2 dogs per kennel" });
      }

      // Family validation: if adding to occupied kennel, check same client
      if (currentDogIds.length > 0 && dogIds.length > 0) {
        const existingDog = await storage.getDog(currentDogIds[0]);
        const newDog = await storage.getDog(dogIds[0]);
        
        if (existingDog && newDog && existingDog.clientId !== newDog.clientId) {
          return res.status(400).json({ 
            message: "Only dogs from the same household may share kennels" 
          });
        }
      }

      // Clear any existing boarding bookings for these dogs and create new ones
      console.log("🔍 Creating bookings for dogs:", dogIds);
      for (const dogId of dogIds) {
        const dog = await storage.getDog(dogId);
        console.log("🐕 Found dog:", dog);
        if (dog) {
          // First, get existing bookings for this dog
          const existingBookings = await storage.getAllBookings();
          const dogBookings = existingBookings.filter(b => b.dogId === dogId && b.serviceType === "boarding");
          
          // Cancel existing boarding bookings for this dog
          for (const existingBooking of dogBookings) {
            console.log("🗑️ Canceling existing booking:", existingBooking.id);
            await storage.updateBooking(existingBooking.id, { status: "cancelled" });
          }
          
          // Create new booking
          const booking = await storage.createBooking({
            clientId: dog.clientId,
            dogId: dogId,
            serviceType: "boarding",
            startDate: new Date(checkInDate),
            endDate: new Date(checkOutDate),
            notes: `Kennel #${kennel.number} assignment`,
          });
          console.log("📅 Created new booking:", booking);
        } else {
          console.log("❌ Dog not found for ID:", dogId);
        }
      }

      // Merge dog IDs (existing + new)
      const allDogIds = [...currentDogIds, ...dogIds];
      
      const updated = await storage.updateKennel(kennelId, {
        dogId: dogIds[0], // Keep backward compatibility
        dogIds: allDogIds,
        status: "occupied",
        checkInDate: new Date(checkInDate),
        checkOutDate: new Date(checkOutDate),
      });

      console.log("✅ Enhanced assignment complete:", updated);
      res.json({ message: "Dogs assigned successfully", kennel: updated });
    } catch (error) {
      console.error("💥 Error in enhanced assignment:", error);
      res.status(500).json({ message: "Failed to assign kennels" });
    }
  });

  app.patch("/api/kennels/:id/unassign", async (req, res) => {
    try {
      const kennelId = parseInt(req.params.id);
      
      const updated = await storage.updateKennel(kennelId, {
        dogId: null,
        dogIds: [],
        status: "available",
        checkInDate: null,
        checkOutDate: null,
      });

      if (!updated) {
        return res.status(404).json({ message: "Kennel not found" });
      }

      res.json({ message: "Kennel unassigned successfully", kennel: updated });
    } catch (error) {
      res.status(500).json({ message: "Failed to unassign kennel" });
    }
  });

  // Job routes
  app.get("/api/jobs", async (req, res) => {
    try {
      const jobs = await storage.getAllJobs();
      res.json(jobs);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/jobs", async (req, res) => {
    try {
      const validatedData = insertJobSchema.parse(req.body);
      const job = await storage.createJob(validatedData);
      res.json(job);
    } catch (error) {
      res.status(500).json({ message: "Failed to create job" });
    }
  });

  app.patch("/api/jobs/:id", async (req, res) => {
    try {
      const jobId = parseInt(req.params.id);
      const updates = req.body;
      
      const updated = await storage.updateJob(jobId, updates);
      
      if (!updated) {
        return res.status(404).json({ message: "Job not found" });
      }
      
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update job" });
    }
  });

  // Booking routes
  app.get("/api/bookings", async (req, res) => {
    try {
      const bookings = await storage.getAllBookings();
      res.json(bookings);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/bookings", async (req, res) => {
    try {
      const validatedData = insertBookingSchema.parse(req.body);
      const booking = await storage.createBooking(validatedData);
      res.json(booking);
    } catch (error) {
      res.status(500).json({ message: "Failed to create booking" });
    }
  });

  // Time entry routes
  app.get("/api/time-entries", async (req, res) => {
    try {
      const entries = await storage.getAllTimeEntries();
      res.json(entries);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/time-entries", async (req, res) => {
    try {
      const validatedData = insertTimeEntrySchema.parse(req.body);
      const entry = await storage.createTimeEntry(validatedData);
      res.json(entry);
    } catch (error) {
      res.status(500).json({ message: "Failed to create time entry" });
    }
  });

  // Daily report routes
  app.get("/api/daily-reports", async (req, res) => {
    try {
      const reports = await storage.getAllKennelLogs();
      res.json(reports);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/daily-reports", async (req, res) => {
    try {
      const validatedData = insertDailyReportSchema.parse(req.body);
      const report = await storage.createDailyReport(validatedData);
      res.json(report);
    } catch (error) {
      res.status(500).json({ message: "Failed to create daily report" });
    }
  });

  // Invoice routes
  app.get("/api/invoices", async (req, res) => {
    try {
      const invoices = await storage.getAllInvoices();
      res.json(invoices);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/invoices", async (req, res) => {
    try {
      const validatedData = insertInvoiceSchema.parse(req.body);
      const invoice = await storage.createInvoice(validatedData);
      res.json(invoice);
    } catch (error) {
      res.status(500).json({ message: "Failed to create invoice" });
    }
  });

  // Kennel log routes
  app.get("/api/kennel-logs", async (req, res) => {
    try {
      const logs = await storage.getAllKennelLogs();
      res.json(logs);
    } catch (error) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/kennel-logs", async (req, res) => {
    try {
      const validatedData = insertKennelLogSchema.parse(req.body);
      const log = await storage.createKennelLog(validatedData);
      res.json(log);
    } catch (error) {
      res.status(500).json({ message: "Failed to create kennel log" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
```

## SERVER/INDEX.TS
```typescript
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic } from "./vite";
import { storage } from "./storage";

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

(async () => {
  // Initialize database with sample data
  console.log("🚀 Initializing database with sample data...");
  
  try {
    // Create admin user if not exists
    const existingAdmin = await storage.getUserByUsername("admin");
    if (!existingAdmin) {
      await storage.createUser({
        username: "admin",
        password: "admin123",
        role: "admin"
      });
    }

    // Create sample staff if not exists
    const existingStaff = await storage.getAllStaff();
    if (existingStaff.length === 0) {
      await storage.createStaff({
        name: "Emma Thompson",
        role: "Head Trainer",
        pin: "1234",
        isActive: true,
        email: "emma@vipelite.com",
        phone: "555-0101",
        hourlyRate: 2500
      });

      await storage.createStaff({
        name: "Marcus Johnson",
        role: "Dog Walker",
        pin: "5678",
        isActive: true,
        email: "marcus@vipelite.com",
        phone: "555-0102",
        hourlyRate: 1800
      });

      await storage.createStaff({
        name: "Sarah Mitchell",
        role: "Kennel Cleaner",
        pin: "9012",
        isActive: true,
        email: "sarah@vipelite.com",
        phone: "555-0103",
        hourlyRate: 1500
      });
    }

    // Create sample client if not exists
    const existingClients = await storage.getAllClients();
    if (existingClients.length === 0) {
      const client = await storage.createClient({
        name: "John Wood",
        email: "info2@whflooringsltd.co.uk",
        phone: "555-0201",
        address: "123 Main Street, Cityville, CV1 2AB",
        emergencyContact: "Jane Wood (Wife)",
        emergencyPhone: "555-0202",
        vetName: "City Veterinary Clinic",
        vetPhone: "555-0301",
        vetAddress: "456 Vet Street, Cityville, CV2 3CD",
        password: "client123",
        isActive: true
      });

      // Create sample dogs for the client
      await storage.createDog({
        name: "Odin",
        breed: "German Shepherd",
        age: 3,
        weight: "35",
        clientId: client.id,
        feedingInstructions: "Twice daily, morning and evening",
        medication: "None",
        behaviorNotes: "Friendly, energetic, good with children",
        allergies: "None known",
        exerciseRequirements: "High energy, needs 2+ hours daily exercise"
      });

      await storage.createDog({
        name: "Diego",
        breed: "Doberman",
        age: 2,
        weight: "30",
        clientId: client.id,
        feedingInstructions: "Dry and wet ",
        medication: "None",
        behaviorNotes: "Energetic, good with family dogs",
        allergies: "None",
        exerciseRequirements: "Very active, needs lots of exercise"
      });
    }

    // Create sample kennels if not exists
    const existingKennels = await storage.getAllKennels();
    if (existingKennels.length === 0) {
      for (let i = 1; i <= 20; i++) {
        await storage.createKennel({
          number: i,
          status: "available"
        });
      }
    }

    console.log("✅ Database initialized successfully");
  } catch (error) {
    console.error("❌ Failed to initialize database:", error);
  }

  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
  });

  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  const PORT = 5000;
  server.listen(PORT, "0.0.0.0", () => {
    console.log(`🚀 Server running on port ${PORT}`);
  });
})();
```

## CLIENT/SRC/APP.TSX
```typescript
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import Home from "@/pages/home";
import AdminLogin from "@/pages/admin-login";
import SimpleAdmin from "@/pages/simple-admin";
import BookingCalendar from "@/pages/BookingCalendar";
import StaffPage from "@/pages/staff-page";
import ClientPage from "@/pages/client-page";
import NotFound from "@/pages/not-found";

function Router() {
  return (
    <Switch>
      <Route path="/" component={Home} />
      <Route path="/admin" component={AdminLogin} />
      <Route path="/admin-dashboard" component={SimpleAdmin} />
      <Route path="/admin/bookings" component={BookingCalendar} />
      <Route path="/staff" component={StaffPage} />
      <Route path="/client" component={ClientPage} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <Router />
        <Toaster />
      </TooltipProvider>
    </QueryClientProvider>
  );
}

export default App;
```

## CLIENT/SRC/LIB/QUERYCLIENT.TS
```typescript
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: async ({ queryKey }) => {
        const response = await fetch(queryKey[0] as string);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      },
      staleTime: 1 * 60 * 1000, // 1 minute
      refetchOnWindowFocus: false,
    },
  },
});

export async function apiRequest(
  method: "GET" | "POST" | "PATCH" | "DELETE",
  url: string,
  data?: any
) {
  const options: RequestInit = {
    method,
    headers: {
      "Content-Type": "application/json",
    },
  };

  if (data) {
    options.body = JSON.stringify(data);
  }

  const response = await fetch(url, options);
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  return response;
}
```

## CLIENT/SRC/PAGES/HOME.TSX
```typescript
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { useLocation } from "wouter";
import logoPath from "@assets/LOGO JPEG.jpg";

export default function Home() {
  const [, setLocation] = useLocation();

  return (
    <div className="min-h-screen bg-gradient-to-br from-black via-gray-900 to-purple-900/30">
      {/* Ornate Border */}
      <div className="absolute inset-0 border-8 border-yellow-400 border-opacity-20 pointer-events-none">
        <div className="absolute inset-2 border-4 border-yellow-400 border-opacity-40">
          <div className="absolute inset-2 border-2 border-yellow-400 border-opacity-60">
          </div>
        </div>
      </div>

      <div className="relative z-10 flex flex-col items-center justify-center min-h-screen p-8">
        {/* Logo */}
        <div className="mb-8">
          <img 
            src={logoPath} 
            alt="VIP Elite K9s" 
            className="h-32 w-32 rounded-full object-cover border-4 border-yellow-400 shadow-2xl"
          />
        </div>

        {/* Main Card */}
        <Card className="w-full max-w-md bg-black/80 backdrop-blur border-2 border-yellow-400 shadow-2xl">
          <CardHeader className="text-center">
            <CardTitle className="text-4xl font-bold text-yellow-400 mb-2">
              👑 VIP Elite K9s
            </CardTitle>
            <CardDescription className="text-xl text-gray-300">
              Premium Dog Management System
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Button
              onClick={() => setLocation("/admin")}
              className="w-full bg-gradient-to-r from-yellow-400 to-yellow-600 hover:from-yellow-500 hover:to-yellow-700 text-black font-bold py-3 text-lg border-2 border-yellow-300"
            >
              🔐 Admin Access
            </Button>
            <Button
              onClick={() => setLocation("/staff")}
              variant="outline"
              className="w-full border-2 border-yellow-400 text-yellow-400 hover:bg-yellow-400/10 font-semibold py-3 text-lg"
            >
              👨‍💼 Staff Login
            </Button>
            <Button
              onClick={() => setLocation("/client")}
              variant="outline"
              className="w-full border-2 border-yellow-400 text-yellow-400 hover:bg-yellow-400/10 font-semibold py-3 text-lg"
            >
              🐕 Client Portal
            </Button>
          </CardContent>
        </Card>

        <div className="mt-8 text-center">
          <p className="text-gray-400 text-sm">
            Professional Dog Boarding & Training Services
          </p>
        </div>
      </div>
    </div>
  );
}
```

## CLIENT/SRC/PAGES/BOOKINGCALENDAR.TSX
```typescript
import React, { useEffect, useState } from "react";
import { format, eachDayOfInterval, parseISO } from "date-fns";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { useLocation } from "wouter";
import { useQuery } from "@tanstack/react-query";

export default function BookingCalendar() {
  const [, setLocation] = useLocation();

  const { data: kennels = [] } = useQuery({ 
    queryKey: ["/api/kennels"],
    refetchOnWindowFocus: true,
    refetchInterval: 5000
  });
  const { data: dogs = [] } = useQuery({ 
    queryKey: ["/api/dogs"],
    refetchOnWindowFocus: true
  });
  const { data: clients = [] } = useQuery({ 
    queryKey: ["/api/clients"],
    refetchOnWindowFocus: true
  });
  const { data: bookings = [] } = useQuery({ 
    queryKey: ["/api/bookings"],
    refetchOnWindowFocus: true,
    refetchInterval: 5000
  });

  const today = new Date();
  const days = eachDayOfInterval({
    start: today,
    end: new Date(today.getTime() + 6 * 86400000),
  });

  return (
    <div className="min-h-screen bg-gradient-to-br from-black via-gray-900 to-purple-900/30 text-white">
      <div className="container mx-auto p-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between mb-6">
          <h1 className="text-3xl font-bold text-yellow-400">📅 Booking Calendar</h1>
          <Button
            onClick={() => setLocation("/admin-dashboard")}
            variant="outline"
            className="border-2 border-yellow-400 text-yellow-400 hover:bg-yellow-400/10 font-semibold"
          >
            ← Back to Dashboard
          </Button>
        </div>

        {/* Calendar */}
        <Card className="bg-black/80 backdrop-blur border-2 border-yellow-400">
          <CardHeader>
            <CardTitle className="text-yellow-400">7-Day Kennel Schedule</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto">
              <table className="w-full border-collapse">
                <thead>
                  <tr>
                    <th className="border border-yellow-400/30 p-3 text-yellow-300 bg-black/60 min-w-[120px]">
                      Kennel
                    </th>
                    {days.map((day) => (
                      <th key={day.toISOString()} className="border border-yellow-400/30 p-3 text-yellow-300 bg-black/60 min-w-[140px]">
                        <div className="text-center">
                          <div className="font-bold">{format(day, "EEE")}</div>
                          <div className="text-sm">{format(day, "MMM d")}</div>
                        </div>
                      </th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {Array.from({ length: 20 }, (_, i) => i + 1).map((kennelNum) => {
                    return (
                      <tr key={kennelNum} className="hover:bg-yellow-400/5">
                        <td className="border border-yellow-400/30 p-3 text-center font-semibold text-yellow-300 bg-black/60">
                          Kennel #{kennelNum}
                        </td>
                        {days.map((day) => {
                          // Find all active bookings for this kennel on this specific day
                          const dayBookings = (bookings as any[]).filter((booking: any) => {
                            if (!booking.startDate || !booking.endDate) return false;
                            if (booking.status === 'cancelled') return false; // Skip cancelled bookings
                            
                            const bookingStart = new Date(booking.startDate);
                            const bookingEnd = new Date(booking.endDate);
                            
                            // Check if this day falls within the booking period
                            return day >= bookingStart && day <= bookingEnd;
                          });

                          // Find kennel to get assigned dogs for this specific kennel
                          const kennel = (kennels as any[]).find((k: any) => k.number === kennelNum);
                          
                          // Filter bookings to only those for dogs currently in this kennel
                          const kennelBookings = dayBookings.filter((booking: any) => {
                            if (!kennel || !kennel.dogIds) return false;
                            return kennel.dogIds.includes(booking.dogId);
                          });

                          const isOccupied = kennelBookings.length > 0;

                          return (
                            <td
                              key={day.toISOString()}
                              className={`border border-yellow-400/30 p-3 text-center text-sm ${
                                isOccupied 
                                  ? "bg-yellow-600 text-black font-bold" 
                                  : "bg-black/40 text-gray-400 hover:bg-yellow-400/10"
                              }`}
                            >
                              {isOccupied ? (
                                <div>
                                  {kennelBookings.map((booking: any, index: number) => {
                                    const dog = (dogs as any[]).find((d: any) => d.id === booking.dogId);
                                    const client = (clients as any[]).find((c: any) => c.id === booking.clientId);
                                    
                                    if (!dog) return null;
                                    
                                    return (
                                      <div key={booking.id} className={index > 0 ? "mt-1 pt-1 border-t border-black/20" : ""}>
                                        <div className="font-bold text-xs">{dog.name}</div>
                                        <div className="text-xs">{dog.breed}</div>
                                        {kennelBookings.length > 1 && client && (
                                          <div className="text-xs opacity-75">{client.name}</div>
                                        )}
                                        <div className="text-xs opacity-75">
                                          Out: {new Date(booking.endDate).toLocaleDateString()}
                                        </div>
                                      </div>
                                    );
                                  })}
                                </div>
                              ) : (
                                <span className="text-gray-500">Available</span>
                              )}
                            </td>
                          );
                        })}
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>

        {/* Legend */}
        <Card className="bg-black/80 backdrop-blur border-2 border-yellow-400">
          <CardContent className="p-4">
            <div className="flex items-center justify-center space-x-6 text-sm">
              <div className="flex items-center space-x-2">
                <div className="w-4 h-4 bg-yellow-600 border"></div>
                <span>Occupied</span>
              </div>
              <div className="flex items-center space-x-2">
                <div className="w-4 h-4 bg-black/40 border border-gray-600"></div>
                <span>Available</span>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

## CONFIGURATION FILES

### VITE.CONFIG.TS
```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client/src"),
      "@shared": path.resolve(__dirname, "shared"),
      "@assets": path.resolve(__dirname, "attached_assets"),
    },
  },
  root: "client",
  build: {
    outDir: "../dist/public",
    emptyOutDir: true,
  },
});
```

### DRIZZLE.CONFIG.TS
```typescript
import "dotenv/config";
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  out: "./drizzle",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

### TAILWIND.CONFIG.TS
```typescript
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: [
    "./client/src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;
```

## END OF SYSTEM EXPORT

This is the complete VIP Elite K9s Management System with:
- ✅ PostgreSQL database with full schema
- ✅ Complete backend API with all routes
- ✅ Admin dashboard with kennel management
- ✅ Staff management with PIN authentication  
- ✅ Client management with full profiles
- ✅ Dog management with detailed care information
- ✅ Kennel assignment system supporting up to 2 dogs per kennel
- ✅ Booking calendar integration
- ✅ Black and gold luxury styling throughout
- ✅ Responsive design with Tailwind CSS
- ✅ TypeScript for type safety
- ✅ All necessary configuration files

The system includes sample data initialization and is ready for deployment.