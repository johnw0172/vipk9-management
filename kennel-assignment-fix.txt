KENNEL ASSIGNMENT VALIDATION ISSUE - COMPLETE CODE

The problem: System is blocking Odin's booking for June 2-16 when Coco already has May 15-30, saying "Cannot exceed 2 dogs per kennel" even though dates don't overlap.

CURRENT VALIDATION LOGIC (server/routes.ts lines 399-430):

```typescript
// Smart validation: check dates and household rules first
const currentDogIds = kennel.dogIds || [];

if (currentDogIds.length > 0 && dogIds.length > 0) {
  const existingDog = await storage.getDog(currentDogIds[0]);
  const newDog = await storage.getDog(dogIds[0]);
  
  if (existingDog && newDog) {
    const newCheckIn = new Date(checkInDate);
    const newCheckOut = new Date(checkOutDate);
    const existingCheckIn = kennel.checkInDate ? new Date(kennel.checkInDate) : new Date();
    const existingCheckOut = kennel.checkOutDate ? new Date(kennel.checkOutDate) : new Date();
    
    // Check for date overlap
    const hasOverlap = newCheckIn < existingCheckOut && newCheckOut > existingCheckIn;
    
    if (hasOverlap) {
      // Same dates - check household rules
      if (existingDog.clientId !== newDog.clientId) {
        return res.status(400).json({ 
          message: `Booking conflict: Kennel occupied by ${existingDog.name} until ${existingCheckOut.toLocaleDateString()}` 
        });
      }
      // Same household - check 2 dog limit for overlapping dates
      const totalDogsOverlapping = currentDogIds.length + dogIds.length;
      if (totalDogsOverlapping > 2) {
        return res.status(400).json({ message: "Cannot exceed 2 dogs per kennel for same dates" });
      }
    }
    // No overlap - allow any household to book different dates
  }
}
```

FULL KENNEL ASSIGNMENT ENDPOINT (server/routes.ts):

```typescript
app.post("/api/kennels/assign", async (req, res) => {
  console.log("ðŸš€ ENHANCED KENNEL ASSIGNMENT STARTED");
  try {
    const { kennelIds, dogIds, checkInDate, checkOutDate } = req.body;
    
    console.log("ðŸ“ Request data:", { kennelIds, dogIds, checkInDate, checkOutDate });

    if (!Array.isArray(kennelIds) || !Array.isArray(dogIds)) {
      return res.status(400).json({ message: "Invalid kennel or dog selection" });
    }

    if (kennelIds.length !== 1) {
      return res.status(400).json({ message: "Can only assign to one kennel at a time" });
    }

    if (dogIds.length > 2) {
      return res.status(400).json({ message: "Maximum 2 dogs per kennel allowed" });
    }

    const kennelId = kennelIds[0];
    const kennel = await storage.getKennel(kennelId);
    
    if (!kennel) {
      return res.status(404).json({ message: "Kennel not found" });
    }

    // Smart validation: check dates and household rules first
    const currentDogIds = kennel.dogIds || [];
    
    if (currentDogIds.length > 0 && dogIds.length > 0) {
      const existingDog = await storage.getDog(currentDogIds[0]);
      const newDog = await storage.getDog(dogIds[0]);
      
      if (existingDog && newDog) {
        const newCheckIn = new Date(checkInDate);
        const newCheckOut = new Date(checkOutDate);
        const existingCheckIn = kennel.checkInDate ? new Date(kennel.checkInDate) : new Date();
        const existingCheckOut = kennel.checkOutDate ? new Date(kennel.checkOutDate) : new Date();
        
        // Check for date overlap
        const hasOverlap = newCheckIn < existingCheckOut && newCheckOut > existingCheckIn;
        
        if (hasOverlap) {
          // Same dates - check household rules
          if (existingDog.clientId !== newDog.clientId) {
            return res.status(400).json({ 
              message: `Booking conflict: Kennel occupied by ${existingDog.name} until ${existingCheckOut.toLocaleDateString()}` 
            });
          }
          // Same household - check 2 dog limit for overlapping dates
          const totalDogsOverlapping = currentDogIds.length + dogIds.length;
          if (totalDogsOverlapping > 2) {
            return res.status(400).json({ message: "Cannot exceed 2 dogs per kennel for same dates" });
          }
        }
        // No overlap - allow any household to book different dates
      }
    }

    // Clear any existing boarding bookings for these dogs and create new ones
    console.log("ðŸ” Creating bookings for dogs:", dogIds);
    for (const dogId of dogIds) {
      const dog = await storage.getDog(dogId);
      console.log("ðŸ• Found dog:", dog);
      if (dog) {
        // First, get existing bookings for this dog
        const existingBookings = await storage.getAllBookings();
        const dogBookings = existingBookings.filter(b => b.dogId === dogId && b.serviceType === "boarding");
        
        // Cancel existing boarding bookings for this dog
        for (const existingBooking of dogBookings) {
          console.log("ðŸ—‘ï¸ Canceling existing booking:", existingBooking.id);
          await storage.updateBooking(existingBooking.id, { status: "cancelled" });
        }
        
        // Create new booking
        const booking = await storage.createBooking({
          clientId: dog.clientId,
          dogId: dogId,
          serviceType: "boarding",
          checkInDate: new Date(checkInDate),
          checkOutDate: new Date(checkOutDate),
          status: "confirmed",
          kennelNumber: kennel.number
        });
        console.log("âœ… Created booking:", booking.id);
      } else {
        console.log("âŒ Dog not found for ID:", dogId);
      }
    }

    // Create individual bookings in the system - don't modify kennel directly
    // The kennel will show the queue count, but individual bookings track the actual dates
    console.log("ðŸŽ¯ Creating separate booking entries for queue system");
    
    // Don't update kennel dogIds - let the booking system handle the queue
    // Just mark kennel as occupied so it shows in the grid
    const updated = await storage.updateKennel(kennelId, {
      status: "occupied",
      // Don't set dogIds here - the display logic will get them from bookings
    });

    // AUTO-ESTIMATE logic follows...
    
    res.json({ message: "Dogs assigned successfully", kennel: updated });
  } catch (error) {
    console.error("ðŸ’¥ Error in enhanced assignment:", error);
    res.status(500).json({ message: "Failed to assign kennels" });
  }
});
```

ISSUE ANALYSIS:
1. The validation checks if kennel has existing dogs (currentDogIds.length > 0)
2. It should allow non-overlapping dates from different households
3. But somewhere it's still hitting a "Cannot exceed 2 dogs per kennel" error
4. Need to ensure the logic properly handles the queue system where multiple bookings can exist for different dates

EXPECTED BEHAVIOR:
- Coco: May 15-30 (Pending)
- Odin: June 2-16 (Pending) 
- Kennel #1 shows "2 Pending"
- Both bookings coexist since dates don't overlap

The error "Cannot exceed 2 dogs per kennel" suggests there's another validation check happening before the date overlap logic.